
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>ST790 Advanced Computing Lab: Introduction to CVX</title><meta name="generator" content="MATLAB 8.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2016-03-02"><meta name="DC.source" content="cvxDemo.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>ST790 Advanced Computing Lab: Introduction to CVX</h1><!--introduction--><p>This file demonstrates how to use the modeling tool CVX to solve optimization problems, and also includes some examples of using MATLAB's and Gurobi's solvers directly.  It was originally created by <a href="http://brgaines.github.io/">Brian Gaines</a> for <a href="http://www.ericchi.com/">Eric Chi</a>'s <a href="http://www.stat.ncsu.edu/people/chi/courses/ST790/">ST790 Advanced Computing</a> at NC State University.  The <a href="http://brgaines.github.io/talks/cvx/cvxDemo.html">companion slidedeck</a> provides additional information on CVX.  The code that generated this file is available (<a href="http://brgaines.github.io/talks/cvx/cvxDemo.m">cvxDemo.m</a>).  Any comments or suggestions are welcome.</p><p><b>This file requires:</b></p><div><ul><li>MATLAB's Optimization Toolbox (if you are an NCSU student, you have this)</li><li>The <a href="http://cvxr.com/cvx/">CVX toolbox</a> for disciplined convex optimization (preferrably with the professional license)</li><li><a href="http://brgaines.github.io/talks/cvx/cvxDemo.mat">cvxDemo.mat</a> data file in the working directory (or the load path will need to be changed)</li><li>A stand-alone installation of the <a href="http://www.gurobi.com/">Gurobi</a> solver is optional.  If you do not have a stand-alone installation of Gurobi, please change the <tt>gurobiInstalled</tt> string to equal <tt>'no'</tt> so the Gurobi-related code will be skipped.</li></ul></div><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Initial Setup</a></li><li><a href="#2">Linear Programming Example: <img src="cvxDemo_eq93608.png" alt="$\ell_1$"> regression (least absolute deviations)</a></li><li><a href="#3">LP Example: Linprog</a></li><li><a href="#8">LP Example: Gurobi</a></li><li><a href="#9">LP Example: CVX</a></li><li><a href="#11">Quadratic Programming Example: Lasso Regression</a></li><li><a href="#12">QP Example: Quadprog</a></li><li><a href="#13">QP Example: Gurobi</a></li><li><a href="#15">QP Example: CVX</a></li><li><a href="#17">Additional Example: 1-norm SVM</a></li></ul></div><h2>Initial Setup<a name="1"></a></h2><pre class="codeinput"><span class="comment">% clean up workspace</span>
clear;

<span class="comment">%######## Does this machine have a stand-alone Gurobi installation?? ########%</span>
<span class="comment">% Answer 'yes' or 'no'</span>
gurobiInstalled = <span class="string">'yes'</span>;

<span class="comment">% load data</span>
load(<span class="string">'cvxDemo'</span>)
</pre><h2>Linear Programming Example: <img src="cvxDemo_eq93608.png" alt="$\ell_1$"> regression (least absolute deviations)<a name="2"></a></h2><p>The first example is <img src="cvxDemo_eq93608.png" alt="$\ell_1$"> regression.  As the name suggests, this is similar to the typical regression setup except that the <img src="cvxDemo_eq93608.png" alt="$\ell_1$"> norm is used for the loss function, so the objective function becomes</p><p>minimize <img src="cvxDemo_eq70660.png" alt="$$ || y - X\beta ||_1 $$"></p><p>To solve this using a linear programming solver, we need to put it in the solver's standard form (which may differ slightly from the standard form Dr. Chi presented in class).</p><h2>LP Example: Linprog<a name="3"></a></h2><p>For MATLAB's <tt>lingprog</tt> function, we see that (from the <a href="http://www.mathworks.com/help/optim/ug/linprog.html">online documentation</a>  or by the command "help linprog" in MATLAB) the problem's form is given by</p><p>minimize <img src="cvxDemo_eq49336.png" alt="$f'x$"></p><p>subject to <img src="cvxDemo_eq53523.png" alt="$Ax \le b$">, <img src="cvxDemo_eq98006.png" alt="$Aeq \cdot x = beq$">, and <img src="cvxDemo_eq25982.png" alt="$lb \le x \le ub$">.</p><p>Once we massage the problem into this form (I will do this on the board), then the corresponding function call is:</p><p>x = linprog(f, A, b, Aeq, beq, lb, ub, x0, options);</p><p>Not all of the inputs are required.  For example, if we only have linear inequaltiy constraints, the function call becomes</p><p>x = linprog(f, A, b);</p><p>If some of the intermediate function inputs are not needed, they need to be replaced by two square brackets, [].  So if we had linear equality constraints but no linear inequality constraints, the code is</p><p>x = linprog(f, [], [], Aeq, beq);</p><p>Anyway, after massaging the <img src="cvxDemo_eq93608.png" alt="$\ell_1$"> regression problem into this form, we can translate it to the code:</p><p><img src="cvxDemo_eq08973.png" alt="$x = \theta = \pmatrix{\beta \cr r}$"></p><p><img src="cvxDemo_eq95961.png" alt="$$f = \pmatrix{0_p \cr 1_n}$$"></p><pre class="codeinput">f = [zeros(p1, 1); ones(n1, 1)];
</pre><p><img src="cvxDemo_eq24688.png" alt="$A = \pmatrix{X &amp; -I_n \cr -X &amp; -I_n}$"></p><pre class="codeinput">A = [X1 -speye(n1); -X1 -speye(n1)];
</pre><p><img src="cvxDemo_eq65791.png" alt="$$b = \pmatrix{y \cr -y}$$"></p><pre class="codeinput">b = [y1; -y1];
</pre><p><img src="cvxDemo_eq84960.png" alt="$\beta \in \mathcal{R}^p$">, and <img src="cvxDemo_eq63239.png" alt="$r \ge 0_n$"></p><pre class="codeinput">lb = [-inf(p1, 1); zeros(n1, 1)];
</pre><p>Now that all of the inputs are set, we can call <tt>lingprog</tt> to estimate the parameters, then extract the first <img src="cvxDemo_eq01166.png" alt="$p$"> parameters as those correspond to <img src="cvxDemo_eq55687.png" alt="$\hat{\beta}$">.</p><pre class="codeinput">tic;                                            <span class="comment">% start timer</span>
thetaHatLP = linprog(f, A, b, [], [], lb);      <span class="comment">% estimate parameters</span>
toc;                                            <span class="comment">% run time</span>
betaHatLP = thetaHatLP(1:p1);                   <span class="comment">% extract estimates for beta</span>
</pre><pre class="codeoutput">Optimization terminated.
Elapsed time is 0.522778 seconds.
</pre><h2>LP Example: Gurobi<a name="8"></a></h2><p>Please note that this requires a standalone installation of <a href="http://www.gurobi.com/academia/for-universities">Gurobi</a>, which is free for academic users but was not required for this lab.  However, I do encourage the knowleddge of a commercial solver such as Gurobi or <a href="https://www.mosek.com/resources/academic-license">MOSEK</a> (both of which are free for academic users, follow the links) as those are state-of-the-art solvers and more efficient than MATLAB's built-in solvers and the R equivalents that I'm aware of (both Gurobi and MOSEK are available in R).</p><p>As before, the first thing we need to do is become familiar with what the standard form looks like according to the solver.  A quick view of this is available through Gurobi's <a href="https://www.gurobi.com/documentation/6.5/refman/matlab_solving_models_with.html">online documentation</a>, while the details are available in the actual <a href="http://www.gurobi.com/documentation/6.5/refman.pdf">reference manual</a> (p. 433).  The relevant parts for our purposes are</p><p>minimize  <img src="cvxDemo_eq56252.png" alt="$x'Qx + c'x + alpha$"></p><p>subject to <img src="cvxDemo_eq95733.png" alt="$Ax = b$"> and <img src="cvxDemo_eq70821.png" alt="$l \le x \le u$">.</p><p>and the function call is</p><p><tt>gurobi(model, params)</tt></p><p>For Gurobi, the <tt>model</tt> argument is pieced together in a <tt>struct</tt> variable (which is essentially like a <tt>list</tt> in R) that contains different fields that correspond to the various parts of the optimization poblem.  The field of a struct is referenced with a period, so the syntax is <tt>struct.field</tt>.</p><p>Here are a few notes on constructing the model, as the implementation is not as straightforward as <tt>linprog</tt>:</p><div><ul><li><img src="cvxDemo_eq27869.png" alt="$c$"> is required (so a vector of zeros is used if it is not needed), and <tt>obj</tt> is its corresponding field (<tt>model.obj</tt>)</li><li><img src="cvxDemo_eq31461.png" alt="$A$"> is also required, and it must be a sparse matrix (using the <tt>sparse</tt> function).  Even if you do not have any constraints in your model, <img src="cvxDemo_eq31461.png" alt="$A$"> is still required and has to be sparse (so simply using [] doesn't work).  As we will see in the lasso example, I usually use <tt>sparse(zeros(0, p));</tt>, where <img src="cvxDemo_eq01166.png" alt="$p$"> is the dimension of the parameter vector/optimization variable, to create a sparse empty matrix.</li><li>Linear inequality constraints are also possible, even though the standard form only has linear equality constraints.  The <tt>sense</tt> field specifies the type of constraint, using either <tt>'='</tt>, <tt>'&lt;'</tt>, or <tt>'&gt;'</tt>.  A single value can be used when all of the constraints are the same, otherwise for mixed constraints there needs to be one value per row of <img src="cvxDemo_eq31461.png" alt="$A$">.  Since <tt>A</tt> is required, <tt>sense</tt> is also required.</li><li>The field for <img src="cvxDemo_eq28812.png" alt="$b$"> is <tt>rhs</tt>.  This is also required.</li><li>The field for <img src="cvxDemo_eq45221.png" alt="$l$"> is <tt>lb</tt>.  This is optional, but please note that the default lower bound is zero, and not <img src="cvxDemo_eq52342.png" alt="$-\infty$">, which can be accomplished by using <tt>-inf(p, 1)</tt>.</li><li><tt>params</tt> is optional and can be used to specify options.  A list of options is available on page 487 of the <a href="http://www.gurobi.com/documentation/6.5/refman.pdf">reference manual</a>.  I typically only set the field <tt>OutputFlag</tt> to <img src="cvxDemo_eq12896.png" alt="$0$"> to suppress the output.</li><li><tt>x</tt> is the field in the output struct that has the solution.  The solution includes several other output fields, detailed on p. 436 of the referencec manual.</li></ul></div><p>Now that we have some background on <tt>gurobi</tt>, we can see it in action:</p><pre class="codeinput"><span class="comment">%# Model Setup #%</span>
<span class="comment">% linear term</span>
gmodel.obj = [zeros(p1, 1); ones(n1, 1)];
<span class="comment">% constraint matrix</span>
gmodel.A = [X1 -speye(n1); -X1 -speye(n1)];
<span class="comment">% constraint type. Only one value needed since all constraints are inequality</span>
gmodel.sense = <span class="string">'&lt;'</span>;
<span class="comment">% b vector for constraints</span>
gmodel.rhs = [y1; -y1];
<span class="comment">% lower bound (needed because default is zero)</span>
gmodel.lb = [-inf(p1, 1); zeros(n1, 1)];
<span class="comment">% suppress output</span>
gparam.OutputFlag = 0;

<span class="comment">%# Model Estimation #%</span>
<span class="keyword">if</span> strcmpi(gurobiInstalled, <span class="string">'yes'</span>)
    tic;                                    <span class="comment">% start timer</span>
    gresult = gurobi(gmodel, gparam);       <span class="comment">% estimate model</span>
    toc;                                    <span class="comment">% run time</span>
    betaHatGurobiLP = gresult.x(1:p1);      <span class="comment">% extract estimates for beta</span>
<span class="keyword">end</span>
</pre><pre class="codeoutput">Elapsed time is 0.007671 seconds.
</pre><h2>LP Example: CVX<a name="9"></a></h2><p>While Gurobi and MOSEK are solvers, <a href="http://cvxr.com/cvx/">CVX</a> is a modeling tool which provides a much more user-friendly interface for solving optimization problems using a variety of solvers, saving the hassle of needing to massage the problem into standard form or the hassle of having to learn each solver's syntax.</p><p>I will get into the details of CVX later, but for now, let's look at how we would solve the <img src="cvxDemo_eq93608.png" alt="$\ell_1$"> regression problem using CVX.</p><pre class="codeinput"><span class="comment">%# Model Estimation #%</span>
tic;                                             <span class="comment">% start timer</span>
cvx_begin <span class="string">quiet</span>                                  <span class="comment">% initiate CVX, hiding output</span>
    variable <span class="string">betaHatCVX_LP(p1)</span>;                  <span class="comment">% declare optimization variable</span>
    minimize( norm(y1 - X1*betaHatCVX_LP, 1) );  <span class="comment">% define objective function</span>
cvx_end                                          <span class="comment">% declare end of CVX statements</span>
toc;                                             <span class="comment">% run time</span>
</pre><p>As you can see, the syntax is much more straightforward and succinct, and essentially translates the original form of the problem directly to code without first having to massage it into an intermediate form for the sake of estimation.  Here</p><pre class="codeinput"><span class="comment">%# Compare estimates #%</span>
<span class="comment">% reduce the number of decimals displayed</span>
format <span class="string">short</span>
<span class="comment">% display estimates</span>
<span class="keyword">if</span> strcmpi(gurobiInstalled, <span class="string">'yes'</span>)
    display([betaHatLP betaHatCVX_LP betaHatGurobiLP])
<span class="keyword">elseif</span> strcmpi(gurobiInstalled, <span class="string">'no'</span>)
    display([betaHatLP betaHatCVX_LP])
<span class="keyword">end</span>
</pre><pre class="codeoutput">Elapsed time is 0.564291 seconds.

ans =

   -0.5722   -0.5722   -0.5722
    0.5249    0.5249    0.5249
    0.6711    0.6711    0.6711
   -0.0283   -0.0283   -0.0283
    0.1598    0.1598    0.1598
    0.8119    0.8119    0.8119
   -0.1091   -0.1091   -0.1091
    0.2011    0.2011    0.2011
    0.0029    0.0029    0.0029

</pre><h2>Quadratic Programming Example: Lasso Regression<a name="11"></a></h2><p>Our second example involves the popular Lasso <a href="http://statweb.stanford.edu/~tibs/lasso/lasso.pdf">(Tibshirani, 1996)</a>, which introduces an <img src="cvxDemo_eq93608.png" alt="$\ell_1$"> penalty term on the regression coefficients in the objective function</p><p>minimize <img src="cvxDemo_eq14262.png" alt="$$ || y - X\beta ||_2^2  + \lambda || \beta ||_1 $$"></p><p>where <img src="cvxDemo_eq15805.png" alt="$\lambda \ge 0$"> is a tuning parameter.</p><p>We will first optimize this directly using both MATLAB's solver (<tt>quadprog</tt>) and Gurobi, which will require us to first transform the problem into each solver's standard form.</p><h2>QP Example: Quadprog<a name="12"></a></h2><p>MATLAB's <tt>quadprog</tt> function naturally extends the <tt>lingprog</tt> function to include a quadratic term (<a href="http://www.mathworks.com/help/optim/ug/quadprog.html">documentation</a>):</p><p>minimize <img src="cvxDemo_eq17655.png" alt="$\frac{1}{2}x'Hx + f'x$"></p><p>subject to <img src="cvxDemo_eq53523.png" alt="$Ax \le b$">, <img src="cvxDemo_eq98006.png" alt="$Aeq \cdot x = beq$">, and <img src="cvxDemo_eq25982.png" alt="$lb \le x \le ub$">.</p><p>and the function call is also similar</p><p>x = quadprog(H, f, A, b, Aeq, beq, lb, ub, x0, options);</p><p>The key trick to reformulating our problem is to represent the parameter vector using its <a href="https://en.wikipedia.org/wiki/Positive_and_negative_parts">positive and negative parts</a>, <img src="cvxDemo_eq68009.png" alt="$\beta = \beta^+ - \beta^-$">, as this allows us to deal with the absolute value in the penalty term, since <img src="cvxDemo_eq56848.png" alt="$|\beta| = \beta^+ + \beta^-$">.  After expanding and rearranging the objective function to match <tt>quadprog</tt>'s standard form, it should look like</p><p><img src="cvxDemo_eq33157.png" alt="$$\frac{1}{2} \pmatrix{\beta^+ \cr \beta^-} '&#xA;\pmatrix{X'X &amp; -X'X \cr -X'X &amp; X'X} \pmatrix{\beta^+ \cr \beta^-} +&#xA;\left( \lambda 1_{2p} - \pmatrix{X'y \cr -X'y} \right)'&#xA;\pmatrix{\beta^+ \cr \beta^-}$$"></p><p>subject to <img src="cvxDemo_eq14851.png" alt="$\beta^+ \ge 0$">, <img src="cvxDemo_eq26482.png" alt="$\beta^- \ge 0$"></p><p>so we can now translate this to code:</p><pre class="codeinput"><span class="comment">%# Model Setup #%</span>
<span class="comment">% Quadratic matrix H</span>
gram = X2'*X2;
H = [gram -gram; -gram gram];
<span class="comment">% constraints</span>
lb2 = zeros(2*p2, 1);
<span class="comment">% constant part of linear coefficient f</span>
Xy2 = X2'*y2;
f2p2 = [Xy2; -Xy2];
<span class="comment">% suppress quadprog output</span>
options = optimset(<span class="string">'Display'</span>, <span class="string">'off'</span>);

<span class="comment">%# Model Estimation #%</span>
<span class="comment">% define grid of tuning parameters</span>
lambdas = (0:2:64);
nLambda = length(lambdas);

<span class="comment">% matrix to store parameter estimates</span>
betaHatPathQP = NaN(p2, nLambda);
<span class="comment">% vector to store estimation time</span>
qpTimerPath = NaN(1, nLambda);

<span class="comment">% estimate model using quadprog, looping over lambdas</span>
<span class="keyword">for</span> k = 1:nLambda
    <span class="comment">% finish constructing f</span>
    f2(1:2*p2, 1) = lambdas(k);
    f2 = f2 - f2p2;

    <span class="comment">% estimate model using quadprog</span>
    tic;
    thetaHatQP = quadprog(H, f2, [], [], [], [], lb2, [], [], options);
    qpTimer = toc;

    <span class="comment">% back out estimates of beta</span>
    betaHatPathQP(:, k) = thetaHatQP(1:p2) - thetaHatQP(p2+1:end);
    <span class="comment">% store estimation time</span>
    qpTimerPath(k) = qpTimer;
<span class="keyword">end</span>
</pre><h2>QP Example: Gurobi<a name="13"></a></h2><p>Gurobi's standard formulation already inludes a quadratic term,</p><p>minimize  <img src="cvxDemo_eq56252.png" alt="$x'Qx + c'x + alpha$"></p><p>subject to <img src="cvxDemo_eq95733.png" alt="$Ax = b$"> and <img src="cvxDemo_eq70821.png" alt="$l \le x \le u$">,</p><p>so we can proceed as before while also including the quadratic matrix, <img src="cvxDemo_eq96887.png" alt="$Q$">, which is required to be sparse.</p><pre class="codeinput"><span class="comment">%# Model Setup #%</span>
<span class="comment">% quadratic matrix</span>
gram = X2'*X2;
gmodel2.Q = sparse([gram -gram; -gram gram])/2;
<span class="comment">% constant part of linear term f</span>
Xy2 = X2'*y2;
</pre><p>Recall from above that <img src="cvxDemo_eq31461.png" alt="$A$"> and <img src="cvxDemo_eq28812.png" alt="$b$"> are required, even if they are not in our model, and that <img src="cvxDemo_eq31461.png" alt="$A$"> has to be a sparse matix (p. 433-4 of the <a href="http://www.gurobi.com/documentation/6.5/refman.pdf">reference manual</a>). So we will create <img src="cvxDemo_eq31461.png" alt="$A$"> as a sparse, empty matrix and <img src="cvxDemo_eq28812.png" alt="$b$"> as an empty vector. Note that <img src="cvxDemo_eq31461.png" alt="$A$">'s dimensions still need to be conformable, but <img src="cvxDemo_eq28812.png" alt="$b$"> can be a 0-by-1 vector.</p><pre class="codeinput"><span class="comment">% Constraint matrix.  This is an empty matrix since it's not in our problem</span>
gmodel2.A = sparse(zeros(0, 2*p2));
<span class="comment">% constraint type</span>
gmodel2.sense = <span class="string">'='</span>;
<span class="comment">% right hand side of constraints (corresponds to b), also empty</span>
gmodel2.rhs = zeros(0, 1);
<span class="comment">% suppress gurobi output;</span>
gparam.OutputFlag = 0;


<span class="comment">%# Model Estimation #%</span>
<span class="keyword">if</span> strcmpi(gurobiInstalled, <span class="string">'yes'</span>)
    <span class="comment">% matrix to store parameter estimates</span>
    betaHatPathGurobi = NaN(p2, nLambda);
    <span class="comment">% vector to store estimation time</span>
    gurobiTimerPath = NaN(1, nLambda);

    <span class="comment">% solve model, looping over lambdas</span>
    <span class="keyword">for</span> k = 1:nLambda
        <span class="comment">% update linear coefficient</span>
        gmodel2.obj = lambdas(k)*ones(2*p2, 1) - [Xy2; -Xy2];

        <span class="comment">% estimate model using Gurobi</span>
        tic;
        gresult = gurobi(gmodel2, gparam);
        gurobiTimer = toc;

        <span class="comment">% store estimated coefficients</span>
        betaHatPathGurobi(:, k) = gresult.x(1:p2) - gresult.x(p2+1:end);
        <span class="comment">% store estimation time</span>
        gurobiTimerPath(k) = gurobiTimer;
    <span class="keyword">end</span>
<span class="keyword">end</span>
</pre><h2>QP Example: CVX<a name="15"></a></h2><p>To solve the lasso in CVX, the implementation is again more straightforward as we can work directly the original formulation.  The core part of the estimatin code is given by</p><pre>   cvx_begin quiet
       variable betaHatCVX_QP(p);
       minimize( 0.5*sum_square(y - X*betaHatCVX_QP) + ...
           lambda*norm(betaHatCVX_QP, 1) );
   cvx_end</pre><p>So to solve the problem n a grid of <img src="cvxDemo_eq23351.png" alt="$\lambda$"> values, we can loop over this as</p><pre class="codeinput"><span class="comment">%# Model Estiation #%</span>
<span class="comment">% matrix to store parameter estimates</span>
betaHatPathCVX = NaN(p2, nLambda);
<span class="comment">% vector to store estimation time</span>
cvxTimerPath = NaN(1, nLambda);

<span class="comment">% solve model, looping over lambdas</span>
<span class="keyword">for</span> k = 1:nLambda
    <span class="comment">% estimate model using CVX</span>
    tic;
    cvx_begin <span class="string">quiet</span>
        variable <span class="string">betaHatCVX_QP(p2)</span>;
        minimize( 0.5*sum_square(y2 - X2*betaHatCVX_QP) + <span class="keyword">...</span>
            lambdas(k)*norm(betaHatCVX_QP, 1) );
    cvx_end
    cvxTimer = toc;

    <span class="comment">% store estimated coefficients</span>
    betaHatPathCVX(:, k) = betaHatCVX_QP;
    <span class="comment">% store estimation time</span>
    cvxTimerPath(k) = cvxTimer;
<span class="keyword">end</span>
</pre><pre class="codeinput"><span class="comment">%# Plot solutions #%</span>
<span class="comment">% Quadprog</span>
figure;
plot(lambdas, betaHatPathQP);
title({<span class="string">'Lasso Solution Path: Using Quadprog'</span>, <span class="keyword">...</span>
    [<span class="string">'Timing: '</span> num2str(sum(qpTimerPath)) <span class="string">' sec.'</span>] })
xlabel(<span class="string">'lambda'</span>);
ylabel(<span class="string">'betaHat(lambda)'</span>);
xlim([min(lambdas), max(lambdas)]);

<span class="comment">% Gurobi</span>
<span class="keyword">if</span> strcmpi(gurobiInstalled, <span class="string">'yes'</span>)
    figure;
    plot(lambdas, betaHatPathGurobi);
    title({<span class="string">'Lasso Solution Path: Using Gurobi'</span>, <span class="keyword">...</span>
        [<span class="string">'Timing: '</span> num2str(sum(gurobiTimerPath)) <span class="string">' sec.'</span>] })
    xlabel(<span class="string">'lambda'</span>);
    ylabel(<span class="string">'betaHat(lambda)'</span>);
    xlim([min(lambdas), max(lambdas)]);
<span class="keyword">end</span>

<span class="comment">% CVX</span>
figure;
plot(lambdas, betaHatPathCVX);
title({<span class="string">'Lasso Solution Path: Using CVX'</span>, <span class="keyword">...</span>
    [<span class="string">'Timing: '</span> num2str(sum(cvxTimerPath)) <span class="string">' sec.'</span>] })
xlabel(<span class="string">'lambda'</span>);
ylabel(<span class="string">'betaHat(lambda)'</span>);
xlim([min(lambdas), max(lambdas)]);
</pre><img vspace="5" hspace="5" src="cvxDemo_01.png" alt=""> <img vspace="5" hspace="5" src="cvxDemo_02.png" alt=""> <img vspace="5" hspace="5" src="cvxDemo_03.png" alt=""> <h2>Additional Example: 1-norm SVM<a name="17"></a></h2><p>Here is an additional example of using CVX, this time for solving a 1-norm SVM <a href="http://dept.stat.lsa.umich.edu/~jizhu/pubs/Zhu-NIPS04.pdf">(Zhu et al., 2004)</a>, which is given by</p><p>minimize <img src="cvxDemo_eq69071.png" alt="$$\sum_{i = 1}^n \left[1 -  y_i \left(\beta_0 + \sum_{j=1}^p x_{ij} \beta_j \right) \right]_+ $$"></p><p>subject to <img src="cvxDemo_eq94761.png" alt="$$ || \beta ||_1 =\sum_{j=1}^p \beta_j \le t $$">,</p><p>where <img src="cvxDemo_eq67808.png" alt="$s \ge 0$"> is a tuning parameter.  This example involves a function, the hinge loss function, that is not already in the CVX function library.  However, we can quickly define a new function for this purpose, and since it follows the DCP ruleset, CVX can identify it as being convex.</p><pre class="codeinput"><span class="comment">% define function handle for hinge loss</span>
hingeLoss = @(x) sum(max(0, 1 - x));
</pre><p>With this in hand, the core part of the estimation code is</p><pre>   cvx_begin quiet
       variable betaHatSVM(p3);
       minimize( hingeLoss(y3.*(X3*betaHatSVM)) );
       subject to;
           norm(betaHatSVM(2:end), 1) &lt;= tValues(k);
   cvx_end</pre><pre class="codeinput"><span class="comment">%# Model Estiation #%</span>
<span class="comment">% create tuning parameter grid</span>
tValues = (0:0.1:2.5);
<span class="comment">% number of tuning parameters to consider</span>
m = length(tValues);

<span class="comment">% matrix to store parameter estimates</span>
betaHatPath3 = NaN(p3, m);
<span class="comment">% vector to store estimation time</span>
svmTimerPath = NaN(1, m);

<span class="comment">% solve model, looping over lambdas</span>
<span class="keyword">for</span> k = 1:m
    <span class="comment">% estimate model using CVX</span>
    tic;
    cvx_begin <span class="string">quiet</span>
        variable <span class="string">betaHatSVM(p3)</span>;
        minimize( hingeLoss(y3.*(X3*betaHatSVM)) );
        subject <span class="string">to</span>;
            norm(betaHatSVM(2:end), 1) &lt;= tValues(k);
    cvx_end
    <span class="comment">% store estimation time</span>
    svmTimerPath(k) = toc;

    <span class="comment">% store estimated coefficients</span>
    betaHatPath3(:, k) = betaHatSVM;
<span class="keyword">end</span>


<span class="comment">% #Plot solution path #%</span>
figure;
plot(tValues, betaHatPath3(2:end, :));
title({<span class="string">'1-norm SVM Solution Path (without intercept)'</span>, <span class="keyword">...</span>
    [<span class="string">'Timing: '</span> num2str(sum(svmTimerPath)) <span class="string">' sec.'</span>] })
xlabel(<span class="string">'t'</span>);
ylabel(<span class="string">'betaHat(t)'</span>);
xlim([min(tValues), max(tValues)]);
</pre><img vspace="5" hspace="5" src="cvxDemo_04.png" alt=""> <p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2014a</a><br></p></div><!--
##### SOURCE BEGIN #####
%% ST790 Advanced Computing Lab: Introduction to CVX
% This file demonstrates how to use the modeling tool CVX to solve optimization
% problems, and also includes some examples of using MATLAB's and Gurobi's 
% solvers directly.  It was originally created by 
% <http://brgaines.github.io/ Brian Gaines> for 
% <http://www.ericchi.com/ Eric Chi>'s 
% <http://www.stat.ncsu.edu/people/chi/courses/ST790/ ST790 Advanced Computing>
% at NC State University.  The 
% <http://brgaines.github.io/talks/cvx/cvxDemo.html companion slidedeck>
% provides additional information on CVX.  The code that generated this file is
% available (<http://brgaines.github.io/talks/cvx/cvxDemo.m cvxDemo.m>).  Any 
% comments or suggestions are welcome.  
% 
% *This file requires:*
%
% * MATLAB's Optimization Toolbox (if you are an NCSU student, you have this)
% * The <http://cvxr.com/cvx/ CVX toolbox> for disciplined convex optimization 
% (preferrably with the professional license)
% * <http://brgaines.github.io/talks/cvx/cvxDemo.mat cvxDemo.mat> data file 
% in the working directory (or the load path will need to be changed)
% * A stand-alone installation of the <http://www.gurobi.com/ Gurobi> solver is 
% optional.  If you do not have a stand-alone installation of Gurobi, please
% change the |gurobiInstalled| string to equal |'no'| so the Gurobi-related 
% code will be skipped.  

%% Initial Setup

% clean up workspace
clear; 

%######## Does this machine have a stand-alone Gurobi installation?? ########%
% Answer 'yes' or 'no'
gurobiInstalled = 'yes'; 

% load data
load('cvxDemo')



%% Linear Programming Example: $\ell_1$ regression (least absolute deviations)
% The first example is $\ell_1$ regression.  As the name suggests, this is
% similar to the typical regression setup except that the $\ell_1$ norm is used 
% for the loss function, so the objective function becomes
%
% minimize $$ || y - X\beta ||_1 $$
%
% To solve this using a linear programming solver, we need to put it in
% the solver's standard form (which may differ slightly from the standard form
% Dr. Chi presented in class).  
%
%%% LP Example: Linprog
% For MATLAB's |lingprog| function, we see that 
% (from the 
% <http://www.mathworks.com/help/optim/ug/linprog.html online documentation>  or 
% by the command "help linprog" in MATLAB) the problem's form is given by
%
% minimize $f'x$ 
%
% subject to $Ax \le b$, $Aeq \cdot x = beq$, and $lb \le x \le ub$.  
% 
% Once we massage the problem into this form (I will do this on the board), then
% the corresponding function call is:
%
% x = linprog(f, A, b, Aeq, beq, lb, ub, x0, options);
% 
% Not all of the inputs are required.  For example, if we only have linear 
% inequaltiy constraints, the function call becomes
%
% x = linprog(f, A, b);
% 
% If some of the intermediate function inputs are not needed, they need to
% be replaced by two square brackets, [].  So if we had linear equality
% constraints but no linear inequality constraints, the code is 
% 
% x = linprog(f, [], [], Aeq, beq);
% 
% Anyway, after massaging the $\ell_1$ regression problem into this form,
% we can translate it to the code:
%
% $x = \theta = \pmatrix{\beta \cr r}$
%
% $$f = \pmatrix{0_p \cr 1_n}$$
f = [zeros(p1, 1); ones(n1, 1)];              
%%% 
% $A = \pmatrix{X & -I_n \cr -X & -I_n}$
%
A = [X1 -speye(n1); -X1 -speye(n1)];                 
%%% 
% $$b = \pmatrix{y \cr -y}$$
b = [y1; -y1];                                    
%%%
% $\beta \in \mathcal{R}^p$, and $r \ge 0_n$
lb = [-inf(p1, 1); zeros(n1, 1)];
%%%
% Now that all of the inputs are set, we can call |lingprog| to estimate
% the parameters, then extract the first $p$ parameters as those correspond
% to $\hat{\beta}$.
tic;                                            % start timer
thetaHatLP = linprog(f, A, b, [], [], lb);      % estimate parameters
toc;                                            % run time
betaHatLP = thetaHatLP(1:p1);                   % extract estimates for beta


%% LP Example: Gurobi
% Please note that this requires a standalone installation of 
% <http://www.gurobi.com/academia/for-universities Gurobi>, which
% is free for academic users but was not required for this lab.  However, I
% do encourage the knowleddge of a commercial solver such as Gurobi or 
% <https://www.mosek.com/resources/academic-license MOSEK>
% (both of which are free for academic users, follow the links) as those are 
% state-of-the-art solvers and more efficient than MATLAB's built-in solvers 
% and the R equivalents that I'm aware of (both Gurobi and MOSEK are available 
% in R).
%  
% As before, the first thing we need to do is become familiar with what the
% standard form looks like according to the solver.  A quick view of this
% is available through Gurobi's
% <https://www.gurobi.com/documentation/6.5/refman/matlab_solving_models_with.html
% online documentation>, while the details are available in the actual 
% <http://www.gurobi.com/documentation/6.5/refman.pdf reference manual> (p.
% 433).  The relevant parts for our purposes are 
%
% minimize  $x'Qx + c'x + alpha$
% 
% subject to $Ax = b$ and $l \le x \le u$.  
%
% and the function call is
%
% |gurobi(model, params)|
% 
% For Gurobi, the |model| argument is pieced together in a |struct| variable 
% (which is essentially like a |list| in R) that contains different fields that 
% correspond to the various parts of the optimization poblem.  The field of a 
% struct is referenced with a period, so the syntax is |struct.field|.  
% 
% Here are a few notes on constructing the model, as the implementation is not 
% as straightforward as |linprog|:
%
% * $c$ is required (so a vector of zeros is used if it is not needed), and 
% |obj| is its corresponding field (|model.obj|)
% * $A$ is also required, and it must be a sparse matrix (using the
% |sparse| function).  Even if you do not have any constraints in your model, 
% $A$ is still required and has to be sparse (so simply using [] doesn't
% work).  As we will see in the lasso example, I usually use
% |sparse(zeros(0, p));|, where $p$ is the dimension of the parameter
% vector/optimization variable, to create a sparse empty matrix.  
% * Linear inequality constraints are also possible, even though the standard 
% form only has linear equality constraints.  The |sense| field specifies the
% type of constraint, using either |'='|, |'<'|, or |'>'|.  A single value
% can be used when all of the constraints are the same, otherwise for mixed
% constraints there needs to be one value per row of $A$.  Since |A| is
% required, |sense| is also required.
% * The field for $b$ is |rhs|.  This is also required.  
% * The field for $l$ is |lb|.  This is optional, but please note that the
% default lower bound is zero, and not $-\infty$, which can be accomplished
% by using |-inf(p, 1)|. 
% * |params| is optional and can be used to specify options.  A list of
% options is available on page 487 of the 
% <http://www.gurobi.com/documentation/6.5/refman.pdf reference manual>.  I
% typically only set the field |OutputFlag| to $0$ to suppress the output.
% * |x| is the field in the output struct that has the solution.  The
% solution includes several other output fields, detailed on p. 436 of the
% referencec manual.
%
% Now that we have some background on |gurobi|, we can see it in action:

%# Model Setup #%
% linear term
gmodel.obj = [zeros(p1, 1); ones(n1, 1)];     
% constraint matrix
gmodel.A = [X1 -speye(n1); -X1 -speye(n1)];
% constraint type. Only one value needed since all constraints are inequality
gmodel.sense = '<';  
% b vector for constraints
gmodel.rhs = [y1; -y1];
% lower bound (needed because default is zero)
gmodel.lb = [-inf(p1, 1); zeros(n1, 1)];
% suppress output
gparam.OutputFlag = 0;

%# Model Estimation #%
if strcmpi(gurobiInstalled, 'yes')
    tic;                                    % start timer
    gresult = gurobi(gmodel, gparam);       % estimate model
    toc;                                    % run time
    betaHatGurobiLP = gresult.x(1:p1);      % extract estimates for beta
end


%% LP Example: CVX
% While Gurobi and MOSEK are solvers, <http://cvxr.com/cvx/ CVX> is a modeling 
% tool which provides a much more user-friendly interface for solving 
% optimization problems using a 
% variety of solvers, saving the hassle of needing to massage the problem
% into standard form or the hassle of having to learn each solver's syntax.  
%
% I will get into the details of CVX later, but for now, let's look at how
% we would solve the $\ell_1$ regression problem using CVX.  

%# Model Estimation #%
tic;                                             % start timer
cvx_begin quiet                                  % initiate CVX, hiding output
    variable betaHatCVX_LP(p1);                  % declare optimization variable
    minimize( norm(y1 - X1*betaHatCVX_LP, 1) );  % define objective function
cvx_end                                          % declare end of CVX statements
toc;                                             % run time
 
%%%
% As you can see, the syntax is much more straightforward and succinct, and
% essentially translates the original form of the problem directly to code 
% without first having to massage it into an intermediate form for the sake of
% estimation.  Here 

%# Compare estimates #%
% reduce the number of decimals displayed
format short
% display estimates
if strcmpi(gurobiInstalled, 'yes')
    display([betaHatLP betaHatCVX_LP betaHatGurobiLP])
elseif strcmpi(gurobiInstalled, 'no')
    display([betaHatLP betaHatCVX_LP])
end




%% Quadratic Programming Example: Lasso Regression
% Our second example involves the popular Lasso 
% <http://statweb.stanford.edu/~tibs/lasso/lasso.pdf (Tibshirani, 1996)>,
% which introduces an $\ell_1$ penalty term on the regression coefficients
% in the objective function
% 
% minimize $$ || y - X\beta ||_2^2  + \lambda || \beta ||_1 $$
% 
% where $\lambda \ge 0$ is a tuning parameter. 
%
% We will first optimize this directly using both MATLAB's
% solver (|quadprog|) and Gurobi, which will require us to first transform the 
% problem into each solver's standard form.  
%
%%% QP Example: Quadprog
% MATLAB's |quadprog| function naturally extends the |lingprog| function to 
% include a quadratic term 
% (<http://www.mathworks.com/help/optim/ug/quadprog.html documentation>):
%
% minimize $\frac{1}{2}x'Hx + f'x$ 
%
% subject to $Ax \le b$, $Aeq \cdot x = beq$, and $lb \le x \le ub$. 
%
% and the function call is also similar
%
% x = quadprog(H, f, A, b, Aeq, beq, lb, ub, x0, options);
%
% The key trick to reformulating our problem is to represent the parameter
% vector using its 
% <https://en.wikipedia.org/wiki/Positive_and_negative_parts positive and
% negative parts>,
% $\beta = \beta^+ -
% \beta^-$, as this allows us to deal with the absolute value in the
% penalty term, since $|\beta| = \beta^+ + \beta^-$.  After expanding and 
% rearranging the objective function to match |quadprog|'s standard form,
% it should look like
%
% $$\frac{1}{2} \pmatrix{\beta^+ \cr \beta^-} ' 
% \pmatrix{X'X & -X'X \cr -X'X & X'X} \pmatrix{\beta^+ \cr \beta^-} + 
% \left( \lambda 1_{2p} - \pmatrix{X'y \cr -X'y} \right)' 
% \pmatrix{\beta^+ \cr \beta^-}$$
%
% subject to $\beta^+ \ge 0$, $\beta^- \ge 0$
% 
% so we can now translate this to code:  
%

%# Model Setup #%
% Quadratic matrix H
gram = X2'*X2;
H = [gram -gram; -gram gram];
% constraints
lb2 = zeros(2*p2, 1);
% constant part of linear coefficient f
Xy2 = X2'*y2;
f2p2 = [Xy2; -Xy2];
% suppress quadprog output
options = optimset('Display', 'off');

%# Model Estimation #%
% define grid of tuning parameters
lambdas = (0:2:64);
nLambda = length(lambdas);

% matrix to store parameter estimates 
betaHatPathQP = NaN(p2, nLambda);
% vector to store estimation time
qpTimerPath = NaN(1, nLambda);

% estimate model using quadprog, looping over lambdas
for k = 1:nLambda
    % finish constructing f
    f2(1:2*p2, 1) = lambdas(k);
    f2 = f2 - f2p2;
    
    % estimate model using quadprog
    tic;
    thetaHatQP = quadprog(H, f2, [], [], [], [], lb2, [], [], options);
    qpTimer = toc;
    
    % back out estimates of beta
    betaHatPathQP(:, k) = thetaHatQP(1:p2) - thetaHatQP(p2+1:end);
    % store estimation time
    qpTimerPath(k) = qpTimer;
end



%% QP Example: Gurobi
% Gurobi's standard formulation already inludes a quadratic term,
%
% minimize  $x'Qx + c'x + alpha$
% 
% subject to $Ax = b$ and $l \le x \le u$,  
% 
% so we can proceed as before while also including the quadratic matrix,
% $Q$, which is required to be sparse.  

%# Model Setup #%
% quadratic matrix
gram = X2'*X2;
gmodel2.Q = sparse([gram -gram; -gram gram])/2;
% constant part of linear term f 
Xy2 = X2'*y2;
%%%
% Recall from above that $A$ and $b$ are required, even if they are not in our 
% model, and that $A$ has to be a sparse matix (p. 433-4 of the 
% <http://www.gurobi.com/documentation/6.5/refman.pdf reference manual>).
% So we will create $A$ as a sparse, empty matrix and $b$ as an empty
% vector. Note that $A$'s dimensions still need to be conformable, but $b$
% can be a 0-by-1 vector.

% Constraint matrix.  This is an empty matrix since it's not in our problem
gmodel2.A = sparse(zeros(0, 2*p2));
% constraint type
gmodel2.sense = '=';
% right hand side of constraints (corresponds to b), also empty
gmodel2.rhs = zeros(0, 1);
% suppress gurobi output;
gparam.OutputFlag = 0;


%# Model Estimation #%
if strcmpi(gurobiInstalled, 'yes')
    % matrix to store parameter estimates
    betaHatPathGurobi = NaN(p2, nLambda);
    % vector to store estimation time
    gurobiTimerPath = NaN(1, nLambda);
    
    % solve model, looping over lambdas
    for k = 1:nLambda
        % update linear coefficient
        gmodel2.obj = lambdas(k)*ones(2*p2, 1) - [Xy2; -Xy2];
        
        % estimate model using Gurobi
        tic;
        gresult = gurobi(gmodel2, gparam);
        gurobiTimer = toc;
        
        % store estimated coefficients
        betaHatPathGurobi(:, k) = gresult.x(1:p2) - gresult.x(p2+1:end);
        % store estimation time
        gurobiTimerPath(k) = gurobiTimer;
    end
end

%% QP Example: CVX
% To solve the lasso in CVX, the implementation is again more
% straightforward as we can work directly the original formulation.  The
% core part of the estimatin code is given by
%
%     cvx_begin quiet
%         variable betaHatCVX_QP(p);
%         minimize( 0.5*sum_square(y - X*betaHatCVX_QP) + ...
%             lambda*norm(betaHatCVX_QP, 1) );
%     cvx_end
%
% So to solve the problem n a grid of $\lambda$ values, we can loop over
% this as 

%# Model Estiation #%
% matrix to store parameter estimates 
betaHatPathCVX = NaN(p2, nLambda);
% vector to store estimation time
cvxTimerPath = NaN(1, nLambda);

% solve model, looping over lambdas
for k = 1:nLambda
    % estimate model using CVX
    tic;
    cvx_begin quiet
        variable betaHatCVX_QP(p2);
        minimize( 0.5*sum_square(y2 - X2*betaHatCVX_QP) + ...
            lambdas(k)*norm(betaHatCVX_QP, 1) );
    cvx_end
    cvxTimer = toc;
    
    % store estimated coefficients
    betaHatPathCVX(:, k) = betaHatCVX_QP;
    % store estimation time
    cvxTimerPath(k) = cvxTimer;
end
%%%
% 

%# Plot solutions #%
% Quadprog
figure;
plot(lambdas, betaHatPathQP);
title({'Lasso Solution Path: Using Quadprog', ...
    ['Timing: ' num2str(sum(qpTimerPath)) ' sec.'] })
xlabel('lambda');
ylabel('betaHat(lambda)');
xlim([min(lambdas), max(lambdas)]);

% Gurobi
if strcmpi(gurobiInstalled, 'yes')
    figure;
    plot(lambdas, betaHatPathGurobi);
    title({'Lasso Solution Path: Using Gurobi', ...
        ['Timing: ' num2str(sum(gurobiTimerPath)) ' sec.'] })
    xlabel('lambda');
    ylabel('betaHat(lambda)');
    xlim([min(lambdas), max(lambdas)]);
end

% CVX
figure;
plot(lambdas, betaHatPathCVX);
title({'Lasso Solution Path: Using CVX', ...
    ['Timing: ' num2str(sum(cvxTimerPath)) ' sec.'] })
xlabel('lambda');
ylabel('betaHat(lambda)');
xlim([min(lambdas), max(lambdas)]);





%% Additional Example: 1-norm SVM
% Here is an additional example of using CVX, this time for solving a
% 1-norm SVM 
% <http://dept.stat.lsa.umich.edu/~jizhu/pubs/Zhu-NIPS04.pdf (Zhu et al.,
% 2004)>, which is given by 
%
% minimize $$\sum_{i = 1}^n \left[1 -  y_i \left(\beta_0 + \sum_{j=1}^p x_{ij} 
% \beta_j \right) \right]_+ $$
%
% subject to $$ || \beta ||_1 =\sum_{j=1}^p \beta_j \le t $$, 
% 
% where $s \ge 0$ is a tuning parameter.  This example involves a function, the 
% hinge loss function, that is not already
% in the CVX function library.  However, we can quickly define a new function 
% for this purpose, and since it follows the DCP ruleset, CVX can identify it as
% being convex.

% define function handle for hinge loss
hingeLoss = @(x) sum(max(0, 1 - x));
%%%
% With this in hand, the core part of the estimation code is
%
%     cvx_begin quiet
%         variable betaHatSVM(p3);
%         minimize( hingeLoss(y3.*(X3*betaHatSVM)) );
%         subject to;
%             norm(betaHatSVM(2:end), 1) <= tValues(k);
%     cvx_end
%

%# Model Estiation #%
% create tuning parameter grid 
tValues = (0:0.1:2.5);
% number of tuning parameters to consider 
m = length(tValues);

% matrix to store parameter estimates 
betaHatPath3 = NaN(p3, m);
% vector to store estimation time
svmTimerPath = NaN(1, m); 

% solve model, looping over lambdas
for k = 1:m
    % estimate model using CVX
    tic;
    cvx_begin quiet
        variable betaHatSVM(p3);
        minimize( hingeLoss(y3.*(X3*betaHatSVM)) );
        subject to;
            norm(betaHatSVM(2:end), 1) <= tValues(k);
    cvx_end
    % store estimation time
    svmTimerPath(k) = toc;
        
    % store estimated coefficients
    betaHatPath3(:, k) = betaHatSVM;
end


% #Plot solution path #%
figure;
plot(tValues, betaHatPath3(2:end, :));
title({'1-norm SVM Solution Path (without intercept)', ...
    ['Timing: ' num2str(sum(svmTimerPath)) ' sec.'] })
xlabel('t');
ylabel('betaHat(t)');
xlim([min(tValues), max(tValues)]);


 

##### SOURCE END #####
--></body></html>